<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Captcha Solver (Tesseract.js)</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b0f14;
      --panel: #141a22;
      --text: #eaf2ff;
      --muted: #95a3b3;
      --accent: #4cc9f0;
      --ok: #5efc8d;
      --warn: #ffb703;
      --err: #ff5d73;
      --border: #243041;
    }
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    .wrap {
      max-width: 1100px; margin: 0 auto; padding: 24px 16px 48px;
      display: grid; gap: 20px;
    }
    header {
      display: flex; align-items: center; justify-content: space-between; gap: 16px; flex-wrap: wrap;
    }
    h1 { font-size: 20px; margin: 0; letter-spacing: 0.3px; }
    .muted { color: var(--muted); font-size: 12px; }
    .panel {
      background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px;
    }
    .row {
      display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center;
    }
    input[type="url"] {
      width: 100%; padding: 12px 14px; border-radius: 10px; border: 1px solid var(--border);
      background: transparent; color: var(--text); outline: none;
      font-size: 14px;
    }
    button {
      padding: 10px 14px; border-radius: 10px; border: 1px solid var(--border);
      background: #1e2733; color: var(--text); cursor: pointer; font-weight: 600;
    }
    button.primary { background: var(--accent); color: #001016; border-color: transparent; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 16px;
    }
    .grid .panel h3 { margin: 0 0 10px; font-size: 14px; color: var(--muted); }
    img, canvas {
      width: 100%; height: auto; background: #0d1117; border: 1px dashed var(--border); border-radius: 8px;
    }
    .status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap; font-size: 12px; color: var(--muted);
      max-height: 180px; overflow: auto; background: #0d121a; border-radius: 8px; padding: 10px; border: 1px solid var(--border);
    }
    .solution {
      display: grid; gap: 6px;
    }
    .solution .val {
      font-size: 28px; font-weight: 800; letter-spacing: 2px; color: var(--ok);
      word-break: break-word;
    }
    .bad { color: var(--err); }
    .warn { color: var(--warn); }
    .row2 { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .small { font-size: 12px; }
    .time { font-variant-numeric: tabular-nums; }
    a { color: var(--accent); text-decoration: none; }
    footer { margin-top: 8px; color: var(--muted); font-size: 12px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@v5.0.3/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Captcha Solver</h1>
        <div class="muted">Browser-based OCR using Tesseract.js. Pass ?url=https://.../image.png</div>
      </div>
      <div class="muted">Solves most simple text captchas</div>
    </header>

    <div class="panel">
      <div class="row">
        <input id="urlInput" type="url" placeholder="https://example.com/captcha.png" />
        <button id="genBtn" title="Generate a local sample captcha">Sample</button>
        <button id="solveBtn" class="primary">Solve</button>
      </div>
      <div class="row2" style="margin-top:8px">
        <div class="small">Current URL: <span id="currentUrl" class="muted"></span></div>
        <div class="small">Elapsed: <span id="elapsed" class="time">0.00s</span></div>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <h3>Original image</h3>
        <img id="img" alt="captcha" />
      </div>
      <div class="panel">
        <h3>Preprocessed (for OCR)</h3>
        <canvas id="procCanvas"></canvas>
      </div>
    </div>

    <div class="panel solution">
      <div class="small muted">Solved text</div>
      <div id="solution" class="val">â€”</div>
      <div class="row2">
        <button id="copyBtn" title="Copy solved text">Copy</button>
        <span id="confidence" class="small muted"></span>
      </div>
    </div>

    <div class="panel">
      <h3>Logs</h3>
      <div id="logs" class="status"></div>
    </div>

    <footer>
      Tip: For best results, provide high-contrast, single-word/line captchas. Cross-origin images must allow CORS.
    </footer>
  </div>

<script>
(function() {
  const els = {
    urlInput: document.getElementById('urlInput'),
    genBtn: document.getElementById('genBtn'),
    solveBtn: document.getElementById('solveBtn'),
    img: document.getElementById('img'),
    procCanvas: document.getElementById('procCanvas'),
    solution: document.getElementById('solution'),
    confidence: document.getElementById('confidence'),
    logs: document.getElementById('logs'),
    currentUrl: document.getElementById('currentUrl'),
    copyBtn: document.getElementById('copyBtn'),
    elapsed: document.getElementById('elapsed'),
  };

  let worker = null;
  let solving = false;
  let timerStart = 0;
  let tickTimer = null;

  function log(msg, level = 'info') {
    const time = new Date().toISOString().split('T')[1].replace('Z','');
    const color = level === 'error' ? 'bad' : level === 'warn' ? 'warn' : '';
    const line = document.createElement('div');
    line.innerHTML = `<span class="muted">${time}</span> ${color ? `<span class="${color}">` : ''}${escapeHtml(msg)}${color ? '</span>' : ''}`;
    els.logs.appendChild(line);
    els.logs.scrollTop = els.logs.scrollHeight;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function setElapsed(start=timerStart) {
    const ms = Date.now() - start;
    els.elapsed.textContent = (ms/1000).toFixed(2) + 's';
  }

  function startTimer() {
    timerStart = Date.now();
    setElapsed();
    clearInterval(tickTimer);
    tickTimer = setInterval(setElapsed, 100);
  }

  function stopTimer() {
    clearInterval(tickTimer);
    setElapsed();
  }

  function parseQueryUrl() {
    const u = new URL(window.location.href);
    return u.searchParams.get('url') || '';
  }

  function updateCurrentUrl(u) {
    els.currentUrl.textContent = u || '(generated sample)';
  }

  function randomText(len=5) {
    const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let s = '';
    for (let i=0; i<len; i++) s += alphabet[Math.floor(Math.random()*alphabet.length)];
    return s;
  }

  function generateSample(width=220, height=90) {
    const code = randomText(5);
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');

    // Background
    const grad = ctx.createLinearGradient(0,0,width,height);
    grad.addColorStop(0, '#e6eef7');
    grad.addColorStop(1, '#c9d8ea');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,width,height);

    // Noise lines
    for (let i=0;i<8;i++) {
      ctx.strokeStyle = `rgba(${120+Math.random()*80|0},${120+Math.random()*80|0},${120+Math.random()*80|0},0.75)`;
      ctx.lineWidth = 1 + Math.random()*1.5;
      ctx.beginPath();
      ctx.moveTo(Math.random()*width, Math.random()*height);
      ctx.bezierCurveTo(Math.random()*width, Math.random()*height, Math.random()*width, Math.random()*height, Math.random()*width, Math.random()*height);
      ctx.stroke();
    }

    // Text with slight rotation per char
    const baseY = height*0.65;
    let x = 20;
    for (let i=0;i<code.length;i++) {
      const ch = code[i];
      const rot = (Math.random()*0.4 - 0.2);
      ctx.save();
      ctx.translate(x, baseY);
      ctx.rotate(rot);
      ctx.font = `700 ${46 + (Math.random()*6|0)}px ui-monospace,monospace`;
      ctx.fillStyle = '#243147';
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0d1526';
      ctx.strokeText(ch, 0, 0);
      ctx.fillText(ch, 0, 0);
      ctx.restore();
      x += 34 + Math.random()*6;
    }

    // Salt-and-pepper noise
    const imgd = ctx.getImageData(0,0,width,height);
    const d = imgd.data;
    for (let i=0; i<width*height; i+=11) {
      const idx = i*4;
      const v = Math.random() < 0.5 ? 0 : 255;
      d[idx] = d[idx+1] = d[idx+2] = v;
      d[idx+3] = 30;
    }
    ctx.putImageData(imgd, 0, 0);

    return { dataUrl: canvas.toDataURL('image/png'), code };
  }

  async function ensureWorker() {
    if (worker) return worker;
    log('Loading Tesseract worker...');
    worker = Tesseract.createWorker({
      logger: m => {
        if (m.status) log(`${m.status} ${(m.progress*100).toFixed(0)}%`);
      },
      langPath: 'https://tessdata.projectnaptha.com/4.0.0'
    });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    // Parameters tuned for single word captchas
    await worker.setParameters({
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
      preserve_interword_spaces: '1',
      user_defined_dpi: '300',
      tessedit_pageseg_mode: '8' // PSM_SINGLE_WORD
    });
    log('Worker ready.');
    return worker;
  }

  function toGrayscaleAndBinarize(img, targetW=420) {
    // Draw image scaled, grayscale, Otsu threshold
    const cnv = els.procCanvas;
    const ctx = cnv.getContext('2d');

    const scale = Math.max(1, targetW / img.width);
    const W = Math.round(img.width * scale);
    const H = Math.round(img.height * scale);
    cnv.width = W; cnv.height = H;

    // Draw scaled with smoothing off to preserve edges
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, 0, 0, W, H);

    let imgData;
    try {
      imgData = ctx.getImageData(0, 0, W, H);
    } catch (e) {
      log('Canvas is tainted (CORS). Skipping preprocessing.', 'warn');
      return null;
    }
    const data = imgData.data;
    const hist = new Uint32Array(256);

    // Grayscale and build histogram
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      // Luma Rec. 601
      const y = (0.299*r + 0.587*g + 0.114*b) | 0;
      data[i] = data[i+1] = data[i+2] = y;
      hist[y]++;
    }

    // Otsu threshold
    const total = W * H;
    let sum = 0;
    for (let t=0;t<256;t++) sum += t * hist[t];
    let sumB = 0, wB = 0, wF = 0, mB = 0, mF = 0, maxVar = 0, thresh = 127;
    for (let t=0;t<256;t++) {
      wB += hist[t];
      if (wB === 0) continue;
      wF = total - wB;
      if (wF === 0) break;
      sumB += t * hist[t];
      mB = sumB / wB;
      mF = (sum - sumB) / wF;
      const between = wB * wF * (mB - mF) * (mB - mF);
      if (between > maxVar) { maxVar = between; thresh = t; }
    }

    // Binarize and slight dilation-like strengthening
    for (let i = 0; i < data.length; i += 4) {
      const v = data[i] > thresh ? 255 : 0;
      data[i] = data[i+1] = data[i+2] = v;
      data[i+3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);
    return cnv;
  }

  async function fetchAsObjectURL(url) {
    try {
      const res = await fetch(url, { mode: 'cors', cache: 'no-cache' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const blob = await res.blob();
      return URL.createObjectURL(blob);
    } catch (e) {
      log(`Fetch failed or CORS blocked: ${e.message}`, 'warn');
      return null;
    }
  }

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = (e) => reject(new Error('Failed to load image'));
      img.src = src;
    });
  }

  function sanitizeText(text) {
    const out = (text || '')
      .replace(/[\s\r\n]+/g, '')
      .replace(/[^0-9A-Za-z]/g, '')
      .toUpperCase();
    return out;
  }

  async function solve(url) {
    if (solving) return;
    solving = true;
    els.solveBtn.disabled = true;
    els.solution.textContent = 'Solving...';
    els.confidence.textContent = '';
    startTimer();

    try {
      updateCurrentUrl(url);
      els.img.src = ''; // reset
      els.procCanvas.width = 10; els.procCanvas.height = 10;

      let displaySrc = url;
      // Try to fetch as object URL to avoid CORS taint
      const objUrl = url.startsWith('data:') ? null : await fetchAsObjectURL(url);
      if (objUrl) displaySrc = objUrl;

      // Display original
      els.img.src = displaySrc;

      // Preprocess if possible
      let inputForOCR = displaySrc;
      try {
        const img = await loadImage(displaySrc);
        const pre = toGrayscaleAndBinarize(img);
        if (pre) inputForOCR = pre; // pass canvas to OCR
      } catch (e) {
        log(`Preprocess image load failed: ${e.message}`, 'warn');
      }

      // Ensure worker and recognize
      await ensureWorker();

      log('Recognizing...');
      const result = await worker.recognize(inputForOCR);
      let { text, confidence } = result.data;
      const cleaned = sanitizeText(text);

      els.solution.textContent = cleaned || '(no text detected)';
      els.confidence.textContent = `Confidence: ${confidence?.toFixed ? confidence.toFixed(1) : confidence}%`;
      const totalMs = Date.now() - timerStart;
      log(`Done in ${(totalMs/1000).toFixed(2)}s. Raw: "${(text||'').trim()}" -> Clean: "${cleaned}" (conf ${confidence})`);
    } catch (e) {
      console.error(e);
      log(`Error: ${e.message}`, 'error');
      els.solution.textContent = '(error)';
      els.confidence.textContent = '';
    } finally {
      stopTimer();
      els.solveBtn.disabled = false;
      solving = false;
    }
  }

  function setUrlParam(url) {
    const u = new URL(window.location.href);
    if (url) u.searchParams.set('url', url);
    else u.searchParams.delete('url');
    history.replaceState(null, '', u.toString());
  }

  // Event handlers
  els.solveBtn.addEventListener('click', () => {
    const val = els.urlInput.value.trim();
    if (val.length === 0) {
      log('Please enter a URL or click Sample.', 'warn');
      return;
    }
    setUrlParam(val);
    solve(val);
  });

  els.genBtn.addEventListener('click', () => {
    const { dataUrl } = generateSample();
    els.urlInput.value = dataUrl;
    setUrlParam('');
    solve(dataUrl);
  });

  els.copyBtn.addEventListener('click', async () => {
    const text = els.solution.textContent || '';
    try {
      await navigator.clipboard.writeText(text);
      log('Copied solved text to clipboard.');
    } catch {
      log('Clipboard write failed.', 'warn');
    }
  });

  // On load: use ?url= param or generate a default sample
  window.addEventListener('load', () => {
    const qurl = parseQueryUrl();
    if (qurl) {
      els.urlInput.value = qurl;
      solve(qurl);
    } else {
      const { dataUrl } = generateSample();
      els.urlInput.value = dataUrl;
      solve(dataUrl);
    }
  });

})();
</script>
</body>
</html>