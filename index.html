<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Captcha Solver (Tesseract.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 0 16px 32px 16px;
      background: Canvas;
      color: CanvasText;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 16px 0;
    }
    h1 {
      font-size: 20px;
      margin: 0;
    }
    .bar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    input[type="url"] {
      flex: 1 1 420px;
      min-width: 240px;
      padding: 10px 12px;
      border: 1px solid #bbb5;
      border-radius: 8px;
      font-size: 14px;
      background: inherit;
      color: inherit;
      outline: none;
    }
    button {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #bbb5;
      background: #0b5fff;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    button.secondary {
      background: transparent;
      color: inherit;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 14px;
      margin-top: 16px;
    }
    .card {
      border: 1px solid #bbb5;
      border-radius: 10px;
      padding: 12px;
      background: color-mix(in oklab, Canvas, #000 3%);
    }
    .card h3 {
      font-size: 14px;
      margin: 0 0 8px 0;
      opacity: 0.8;
    }
    .preview {
      display: grid;
      place-items: center;
      min-height: 120px;
      background: repeating-conic-gradient(from 0deg, #00000005 0 25%, transparent 0 50%) 0/12px 12px;
      border-radius: 8px;
      border: 1px dashed #bbb7;
      overflow: hidden;
    }
    img, canvas {
      max-width: 100%;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }
    .status {
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.9;
      white-space: pre-wrap;
    }
    .result {
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 2px;
      word-break: break-word;
      margin: 8px 0 0 0;
    }
    .hint {
      font-size: 12px;
      opacity: 0.7;
    }
    footer {
      margin-top: 24px;
      font-size: 12px;
      opacity: 0.75;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    label {
      font-size: 12px;
      opacity: 0.8;
    }
    .prog {
      height: 8px;
      border-radius: 999px;
      background: #00000010;
      overflow: hidden;
      margin-top: 6px;
      border: 1px solid #bbb5;
    }
    .prog > div {
      height: 100%;
      background: linear-gradient(90deg, #0b5fff, #3ddc97);
      width: 0%;
      transition: width 0.2s ease;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
  </style>
</head>
<body>
  <header>
    <h1>Captcha Solver</h1>
    <div class="bar">
      <input id="urlInput" type="url" placeholder="Paste captcha image URL (or leave empty to use sample)" />
      <button id="solveBtn">Solve</button>
      <button id="sampleBtn" class="secondary" title="Use built-in sample">Sample</button>
    </div>
  </header>

  <div class="grid">
    <div class="card">
      <h3>Original</h3>
      <div class="preview">
        <img id="captchaImg" alt="Captcha preview" crossorigin="anonymous" />
      </div>
      <div class="row">
        <label class="hint">Source: <span id="srcLabel" class="mono"></span></label>
      </div>
    </div>
    <div class="card">
      <h3>Preprocessed</h3>
      <div class="preview">
        <canvas id="procCanvas"></canvas>
      </div>
      <div class="row">
        <label><input id="invertToggle" type="checkbox" /> Invert</label>
        <label><input id="binarizeToggle" type="checkbox" checked /> Binarize</label>
        <label><input id="denoiseToggle" type="checkbox" checked /> Denoise</label>
        <label><input id="scaleSelect" type="range" min="1" max="4" value="2" step="0.5" /> Scale</label>
      </div>
    </div>
    <div class="card">
      <h3>Result</h3>
      <div class="status mono" id="status">Idle</div>
      <div class="prog"><div id="progressBar"></div></div>
      <div class="result mono" id="resultText">—</div>
      <div class="hint">Tries to solve within ~15 seconds using Tesseract.js (PSM: single line, whitelist: A–Z a–z 0–9)</div>
    </div>
  </div>

  <footer>
    Tip: You can pass an image URL via the "url" query param, e.g. ?url=https://example.com/captcha.png
  </footer>

  <!-- Tesseract.js from CDN -->
  <script src="https://unpkg.com/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <script>
    // Utilities
    function $(id){ return document.getElementById(id); }
    function getQueryParam(name){
      const u = new URL(window.location.href);
      return u.searchParams.get(name);
    }
    function setQueryParam(name, value) {
      const u = new URL(window.location.href);
      if (value) u.searchParams.set(name, value);
      else u.searchParams.delete(name);
      history.replaceState({}, "", u.toString());
    }
    function defaultSampleDataURL() {
      // SVG-based sample to avoid large base64 PNG; clean sans-serif text with slight rotation and noise lines.
      const text = "AB12";
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="160" height="60">
          <defs>
            <filter id="noise">
              <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" stitchTiles="stitch" />
              <feColorMatrix type="saturate" values="0"/>
              <feComponentTransfer>
                <feFuncA type="table" tableValues="0 0 0.02 0"/>
              </feComponentTransfer>
            </filter>
          </defs>
          <rect width="100%" height="100%" fill="#ffffff"/>
          <g transform="translate(80,32) rotate(-4)">
            <text x="0" y="0" dominant-baseline="middle" text-anchor="middle"
              font-family="Arial, sans-serif" font-size="36" font-weight="700" fill="#111">
              ${text}
            </text>
          </g>
          <g stroke="#333" stroke-width="1" opacity="0.5">
            <line x1="5" y1="10" x2="155" y2="12"/>
            <line x1="12" y1="50" x2="148" y2="46"/>
          </g>
          <rect width="100%" height="100%" filter="url(#noise)"/>
        </svg>`;
      return "data:image/svg+xml;charset=utf8," + encodeURIComponent(svg);
    }

    // Global state
    let workerPromise = null;
    let workerReady = false;
    let solving = false;
    let lastSolveAbort = null;
    let statusTimer = null;

    const els = {
      urlInput: $('urlInput'),
      solveBtn: $('solveBtn'),
      sampleBtn: $('sampleBtn'),
      captchaImg: $('captchaImg'),
      procCanvas: $('procCanvas'),
      resultText: $('resultText'),
      status: $('status'),
      progressBar: $('progressBar'),
      srcLabel: $('srcLabel'),
      invertToggle: $('invertToggle'),
      binarizeToggle: $('binarizeToggle'),
      denoiseToggle: $('denoiseToggle'),
      scaleSelect: $('scaleSelect')
    };

    function logStatus(msg){ els.status.textContent = msg; }
    function setProgress(pct){ els.progressBar.style.width = Math.max(0, Math.min(100, pct)) + "%"; }

    async function getWorker() {
      if (workerPromise) return workerPromise;
      workerPromise = (async () => {
        logStatus("Loading OCR engine...");
        const worker = await Tesseract.createWorker({
          logger: m => {
            if (m.status && m.progress != null) {
              logStatus(`${m.status} ${(m.progress*100).toFixed(0)}%`);
              setProgress(m.progress*100);
            }
          },
        });
        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        await worker.setParameters({
          // Whitelist common captcha charset
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
          tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE
        });
        workerReady = true;
        return worker;
      })();
      return workerPromise;
    }

    function drawPreprocessed(img) {
      const canvas = els.procCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const scaleFactor = parseFloat(els.scaleSelect.value) || 2;
      const targetW = Math.max(1, Math.floor(img.naturalWidth * scaleFactor));
      const targetH = Math.max(1, Math.floor(img.naturalHeight * scaleFactor));
      canvas.width = targetW;
      canvas.height = targetH;
      // Draw scaled
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0, targetW, targetH);
      // Get pixels
      let imgData = ctx.getImageData(0, 0, targetW, targetH);
      const data = imgData.data;

      // Grayscale (luma)
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        const y = Math.round(0.299*r + 0.587*g + 0.114*b);
        data[i] = data[i+1] = data[i+2] = y;
      }

      // Optional denoise (simple 3x3 median)
      if (els.denoiseToggle.checked) {
        const copy = new Uint8ClampedArray(data);
        const w = targetW, h = targetH;
        const idx = (x,y) => 4*(y*w + x);
        for (let y=1;y<h-1;y++){
          for (let x=1;x<w-1;x++){
            const vals = [];
            for (let j=-1;j<=1;j++){
              for (let i=-1;i<=1;i++){
                vals.push(copy[idx(x+i,y+j)]);
              }
            }
            vals.sort((a,b)=>a-b);
            const m = vals[4];
            const k = idx(x,y);
            data[k]=data[k+1]=data[k+2]=m;
          }
        }
      }

      // Otsu threshold
      let threshold = 127;
      if (els.binarizeToggle.checked) {
        const hist = new Uint32Array(256);
        for (let i=0;i<data.length;i+=4) hist[data[i]]++;
        threshold = otsu(hist, (targetW * targetH));
        for (let i=0;i<data.length;i+=4) {
          const v = data[i] > threshold ? 255 : 0;
          data[i]=data[i+1]=data[i+2]=v;
        }
      }

      // Optional invert
      if (els.invertToggle.checked) {
        for (let i=0;i<data.length;i+=4) {
          data[i]=255-data[i];
          data[i+1]=255-data[i+1];
          data[i+2]=255-data[i+2];
        }
      }

      ctx.putImageData(imgData, 0, 0);
      return canvas;
    }

    function otsu(hist, total) {
      let sum = 0;
      for (let t=0;t<256;t++) sum += t * hist[t];
      let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 0;
      for (let t=0;t<256;t++) {
        wB += hist[t];
        if (wB === 0) continue;
        wF = total - wB;
        if (wF === 0) break;
        sumB += t * hist[t];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        const between = wB * wF * (mB - mF) * (mB - mF);
        if (between > varMax) {
          varMax = between; threshold = t;
        }
      }
      return threshold;
    }

    function setImageSource(src) {
      els.captchaImg.src = "";
      els.captchaImg.crossOrigin = "anonymous";
      els.captchaImg.src = src;
      els.srcLabel.textContent = src.length > 72 ? src.slice(0, 69) + "..." : src;
    }

    async function solveCurrent() {
      if (solving) {
        return;
      }
      solving = true;
      els.solveBtn.disabled = true;
      els.resultText.textContent = "…";
      setProgress(0);
      logStatus("Preparing...");

      // Abort controller for the 15s requirement
      const abortController = new AbortController();
      lastSolveAbort = abortController;
      const fifteenSec = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("timeout")), 15000);
      });

      const img = els.captchaImg;
      try {
        await imgDecode(img);
      } catch (e) {
        logStatus("Failed to load image. Check URL or CORS.");
        els.resultText.textContent = "Load error";
        solving = false;
        els.solveBtn.disabled = false;
        return;
      }

      // Preprocess quickly
      let canvas = drawPreprocessed(img);

      // Start worker load in parallel
      const worker = await getWorker();

      // Rebuild canvas if user toggles while solving
      const uiObserver = new MutationObserver(() => {
        if (!solving) return;
        canvas = drawPreprocessed(img);
      });
      // Observe toggles
      uiObserver.observe(document.body, { attributes: true, subtree: true }); // crude but fine for this demo
      const finish = () => { uiObserver.disconnect(); };

      // Race recognition against 15s timer
      logStatus("Recognizing...");
      try {
        const recogPromise = worker.recognize(canvas);
        const { data } = await Promise.race([recogPromise, fifteenSec]);
        let text = (data && data.text || "").trim();
        logStatus("Done");
        setProgress(100);
        if (!text) text = "[empty]";
        els.resultText.textContent = text;
      } catch (e) {
        if (e && e.message === "timeout") {
          logStatus("Timed out at 15s. Showing best-effort quick guess...");
          // Quick guess: try without denoise/binarize constraints as fallback
          // Minimal extra attempt (fast)
          try {
            els.binarizeToggle.checked = true;
            els.denoiseToggle.checked = false;
            els.invertToggle.checked = false;
            canvas = drawPreprocessed(img);
            const { data } = await Promise.race([
              worker.recognize(canvas),
              new Promise((_, reject) => setTimeout(() => reject(new Error("fallback-timeout")), 3000))
            ]);
            let text = (data && data.text || "").trim();
            els.resultText.textContent = text || "[no result]";
          } catch {
            els.resultText.textContent = "[timeout]";
          }
        } else {
          logStatus("Recognition error");
          els.resultText.textContent = "[error]";
          console.error(e);
        }
      } finally {
        finish();
        solving = false;
        els.solveBtn.disabled = false;
      }
    }

    function imgDecode(imgEl) {
      return new Promise((resolve, reject) => {
        if (imgEl.complete && imgEl.naturalWidth) return resolve();
        const onLoad = () => { cleanup(); resolve(); };
        const onErr = () => { cleanup(); reject(new Error("image-error")); };
        const cleanup = () => {
          imgEl.removeEventListener('load', onLoad);
          imgEl.removeEventListener('error', onErr);
        };
        imgEl.addEventListener('load', onLoad);
        imgEl.addEventListener('error', onErr);
      });
    }

    function applyFromQueryOrDefault() {
      const qUrl = getQueryParam('url');
      const src = qUrl || defaultSampleDataURL();
      if (!qUrl) setQueryParam('url', src);
      els.urlInput.value = src;
      setImageSource(src);
    }

    // Events
    els.solveBtn.addEventListener('click', () => {
      const val = els.urlInput.value.trim();
      if (val) {
        setQueryParam('url', val);
        setImageSource(val);
      }
      solveCurrent();
    });

    els.sampleBtn.addEventListener('click', () => {
      const sample = defaultSampleDataURL();
      els.urlInput.value = sample;
      setQueryParam('url', sample);
      setImageSource(sample);
      solveCurrent();
    });

    els.captchaImg.addEventListener('load', () => {
      drawPreprocessed(els.captchaImg);
    });
    [els.invertToggle, els.binarizeToggle, els.denoiseToggle, els.scaleSelect].forEach(el => {
      el.addEventListener('input', () => {
        if (els.captchaImg.naturalWidth) {
          drawPreprocessed(els.captchaImg);
        }
      });
    });

    // Init
    (async function init(){
      applyFromQueryOrDefault();
      // Warm up worker early to save time
      getWorker().catch(err => console.error(err));
      // Auto-solve on first load
      // Wait for image to be ready
      try {
        await imgDecode(els.captchaImg);
      } catch {}
      drawPreprocessed(els.captchaImg);
      solveCurrent();
    })();
  </script>
</body>
</html>